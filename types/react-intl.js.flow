/**
 * `react-intl`, translated from react-intl/react-intl.d.ts, with minimal
 * tweaks to make it work.
 *
 * This used to refer to types from React's TypeScript libdef,
 * @types/react. We've translated those places to use Flow instead,
 * hopefully without errors or too much loss of information.
 *
 * @flow strict-local
 */

/**
 * Flowtype definitions for react-intl
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 */

import type { SubsetProperties } from '../src/generics';

type ArgumentElement = BaseElement<typeof TYPE.argument>;
interface BaseElement<T: $Values<typeof TYPE>> {
  type: T;
  value: string;
  location?: Location_2;
}
/**
 * Create intl object
 * @param config intl config
 * @param cache cache for formatter instances to prevent memory leak
 */
declare export function createIntl(config: OptionalIntlConfig, cache?: IntlCache): IntlShape;
declare export function createIntlCache(): IntlCache;
type CurrencyCode = string;
export interface CustomFormatConfig {
  format?: string;
}
export type CustomFormats = {
  relative?: {| [key: string]: IntlRelativeTimeFormatOptions |},
  ...
} & $Rest<Formats, { ... }>;
type DateElement = SimpleFormatElement<typeof TYPE.date, DateTimeSkeleton>;
type DateTimeFormatOptions = {
  hourCycle?: 'h11' | 'h12' | 'h23' | 'h24',
  dateStyle?: 'full' | 'long' | 'medium' | 'short',
  timeStyle?: 'full' | 'long' | 'medium' | 'short',
  fractionalSecondDigits?: number,
  calendar?: | 'buddhist'
    | 'chinese'
    | 'coptic'
    | 'ethiopia'
    | 'ethiopic'
    | 'gregory'
    | 'hebrew'
    | 'indian'
    | 'islamic'
    | 'iso8601'
    | 'japanese'
    | 'persian'
    | 'roc',
  numberingSystem?: string,
  ...
} & Intl$DateTimeFormatOptions;
interface DateTimeSkeleton {
  type: typeof SKELETON_TYPE.dateTime;
  pattern: string;
  location?: Location_2;
}
declare var DEFAULT_INTL_CONFIG: SubsetProperties<
  IntlConfig,
  {|
    formats: mixed,
    messages: mixed,
    timeZone?: mixed,
    textComponent?: mixed,
    defaultLocale: mixed,
    defaultFormats: mixed,
    onError: mixed,
  |},
>;
declare export function defineMessage<T>(msg: T): T;
declare export function defineMessages<K: $Keys<$FlowFixMe>, T, U: {| [key: K]: T |}>(msgs: U): U;
declare class DisplayNames {
  constructor(locales?: string | string[], options?: DisplayNamesOptions): this;
  static supportedLocalesOf(
    locales?: string | string[],
    options?: SubsetProperties<DisplayNamesOptions, {| localeMatcher?: mixed |}>,
  ): string[];
  static __addLocaleData(...data: DisplayNamesLocaleData[]): void;
  of(code: string | number | {| [key: string]: $FlowFixMe |}): string | void;
  resolvedOptions(): DisplayNamesResolvedOptions;
  static localeData: {| [key: string]: DisplayNamesData |};
  static +polyfilled: $FlowFixMe; // true
}
interface DisplayNamesData {
  /**
   * Note that for style fields, `short` and `narrow` might not exist.
   * At runtime, the fallback order will be narrow -> short -> long.
   */
  types: {
    /**
     * Maps language subtag like `zh-CN` to their display names.
     */
    language: {
      narrow: {| [key: LanguageTag]: string |},
      short: {| [key: LanguageTag]: string |},
      long: {| [key: LanguageTag]: string |},
      ...
    },
    region: {
      narrow: {| [key: RegionCode]: string |},
      short: {| [key: RegionCode]: string |},
      long: {| [key: RegionCode]: string |},
      ...
    },
    script: {
      narrow: {| [key: ScriptCode]: string |},
      short: {| [key: ScriptCode]: string |},
      long: {| [key: ScriptCode]: string |},
      ...
    },
    currency: {
      narrow: {| [key: CurrencyCode]: string |},
      short: {| [key: CurrencyCode]: string |},
      long: {| [key: CurrencyCode]: string |},
      ...
    },
    ...
  };

  /**
   * Not in spec, but we need this to display both language and region in display name.
   * e.g. zh-Hans-SG + "{0}（{1}）" -> 简体中文（新加坡）
   * Here {0} is replaced by language display name and {1} is replaced by region display name.
   */
  patterns: {
    locale: string,
    ...
  };
}
type DisplayNamesLocaleData = LocaleData<DisplayNamesData>;
interface DisplayNamesOptions {
  localeMatcher?: 'lookup' | 'best fit';
  style?: 'narrow' | 'short' | 'long';
  type?: 'language' | 'region' | 'script' | 'currency';
  fallback?: 'code' | 'none';
}
interface DisplayNamesResolvedOptions {
  locale: string;
  style: $NonMaybeType<DisplayNamesOptions['style']>;
  type: $NonMaybeType<DisplayNamesOptions['type']>;
  fallback: $NonMaybeType<DisplayNamesOptions['fallback']>;
}
interface ElementPart {
  type: 'element';
  value: string;
}
declare var ErrorCode: {|
  +MISSING_VALUE: 'MISSING_VALUE', // "MISSING_VALUE"
  +INVALID_VALUE: 'INVALID_VALUE', // "INVALID_VALUE"
  +MISSING_INTL_API: 'MISSING_INTL_API', // "MISSING_INTL_API"
|};
interface FieldData {
  // $FlowFixMe[unsupported-syntax] - illegal name (these fixmes added in TS to Flow translation)
  '0'?: string;
  // $FlowFixMe[unsupported-syntax] - illegal name
  '1'?: string;
  // $FlowFixMe[unsupported-syntax] - illegal name
  '-1'?: string;
  // $FlowFixMe[unsupported-syntax] - illegal name
  '2'?: string;
  // $FlowFixMe[unsupported-syntax] - illegal name
  '-2'?: string;
  // $FlowFixMe[unsupported-syntax] - illegal name
  '3'?: string;
  // $FlowFixMe[unsupported-syntax] - illegal name
  '-3'?: string;
  future: RelativeTimeData;
  past: RelativeTimeData;
}
export type FormatDateOptions = $Rest<DateTimeFormatOptions, { localeMatcher: mixed }> &
  CustomFormatConfig;
export type FormatDisplayNameOptions = $Rest<DateTimeFormatOptions, { localeMatcher: mixed }>;
declare class FormatError mixins Error {
  +code: $Values<typeof ErrorCode>;

  /**
   * Original message we're trying to format
   * `undefined` if we're only dealing w/ AST
   * @type {(string | void)}
   * @memberof FormatError
   */
  +originalMessage: string | void;
  constructor(msg: string, code: $Values<typeof ErrorCode>, originalMessage?: string): this;
  toString(): string;
}
export type FormatListOptions = $Rest<IntlListFormatOptions, { localeMatcher: mixed }>;
export type FormatNumberOptions = $Rest<NumberFormatOptions, { localeMatcher: mixed }> &
  CustomFormatConfig;
export type FormatPluralOptions = $Rest<Intl$PluralRulesOptions, { localeMatcher: mixed }> &
  CustomFormatConfig;
export type FormatRelativeTimeOptions = $Rest<
  IntlRelativeTimeFormatOptions,
  { localeMatcher: mixed },
> &
  CustomFormatConfig;
interface Formats {
  number: {| [key: string]: Intl$NumberFormatOptions |};
  date: {| [key: string]: Intl$DateTimeFormatOptions |};
  time: {| [key: string]: Intl$DateTimeFormatOptions |};
}
type FormattableUnit = Unit | Units;
declare export var FormattedDate: React$StatelessFunctionalComponent<
  DateTimeFormatOptions &
    CustomFormatConfig & {
      value: string | number | Date | void,
      ...
    }, >;
declare export var FormattedDateParts: React$StatelessFunctionalComponent<
  FormatDateOptions & {
    value: Date | number | string, // Param of Intl.DateTimeFormat.prototype.format(), or `string`
    children(val: $Call<Intl$DateTimeFormat['formatToParts'], mixed[]>): React$Element<React$ElementType> | null,
    ...
  }, >;
declare export var FormattedDisplayName: React$StatelessFunctionalComponent<
  DisplayNamesOptions & {
    value: string | number | {| [key: string]: $FlowFixMe |},
    ...
  }, >;
declare export var FormattedList: React$StatelessFunctionalComponent<
  IntlListFormatOptions & {
    value: React$Node[],
    ...
  }, >;
declare export class FormattedMessage<
  V: {| +[key: string]: $FlowFixMe |} = {|
    +[key: string]:
      | PrimitiveType
      | React$Element<React$ElementType>
      | FormatXMLElementFn<React$Node, React$Node>,
  |},
  // Changed `mixins` to `extends` in TS to Flow translation
> extends React$Component<Props_3<V>> {
  shouldComponentUpdate(nextProps: Props_3<V>): boolean;
  render(): React$Node;
}
declare export var FormattedNumber: React$StatelessFunctionalComponent<
  NumberFormatOptions &
    CustomFormatConfig & {
      value: number,
      ...
    }, >;
declare export var FormattedNumberParts: React$StatelessFunctionalComponent<
  Formatter['formatNumber'] & {
      // Param type of our IntlShape.formatNumber, alias of our
      // IntlFormatters.formatNumber
    value: number,

    // Callers will get a Flow error until Flow adds a built-in
    // definition for Intl.NumberFormat.prototype.formatToParts():
    //   https://github.com/facebook/flow/issues/8859
    children(val: $Call<Intl$NumberFormat['formatToParts'], mixed[]>): React$Element<React$ElementType> | null,
    ...
  }, >;
declare export var FormattedPlural: React$StatelessFunctionalComponent<WithIntlProps<Props_2>> & {
  WrappedComponent: React$ComponentType<Props_2>,
  ...
};
// Changed `mixins` to `extends` in TS to Flow translation
declare export class FormattedRelativeTime extends React$PureComponent<Props, State_2> {
  _updateTimer: $FlowFixMe;
  static defaultProps: SubsetProperties<Props, {| unit?: mixed, value?: mixed |}>;
  state: State_2;
  constructor(props: Props): this;
  scheduleNextUpdate(x: Props, x: State_2): void;
  componentDidMount(): void;
  componentDidUpdate(): void;
  componentWillUnmount(): void;
  static getDerivedStateFromProps(props: Props, state: State_2): $Rest<State_2, { ... }> | null;
  render(): React$Node;
}
declare export var FormattedTime: React$StatelessFunctionalComponent<
  DateTimeFormatOptions &
    CustomFormatConfig & {
      value: string | number | Date | void,
      ...
    }, >;
declare export var FormattedTimeParts: React$StatelessFunctionalComponent<
  FormatDateOptions & {
    value: Date | number | string, // Param of Intl.DateTimeFormat.prototype.format(), or `string`
    children(val: $Call<Intl$DateTimeFormat['formatToParts'], mixed[]>): React$Element<React$ElementType> | null,
    ...
  }, >;
type Formatter = {
  formatDate: FormatDateOptions,
  formatTime: FormatDateOptions,
  formatNumber: FormatNumberOptions,
  formatList: FormatListOptions,
  formatDisplayName: FormatDisplayNameOptions,
  ...
};

// FlowIssue: Looks like we really want something like
//     getDateTimeFormat: ConstructorOf<Intl.DateTimeFormat>
//   but Flow doesn't have something like ConstructorOf; see
//     https://github.com/facebook/flow/issues/1409#issuecomment-184443566
type ConstructorParameters<C> = $FlowIssue[];
export interface Formatters {
  getDateTimeFormat(
    ...args: ConstructorParameters<typeof Intl.DateTimeFormat>
  ): Intl$DateTimeFormat;
  getNumberFormat(...args: ConstructorParameters<typeof Intl.NumberFormat>): Intl$NumberFormat;
  getMessageFormat(...args: ConstructorParameters<typeof IntlMessageFormat>): IntlMessageFormat;
  getRelativeTimeFormat(
    ...args: ConstructorParameters<typeof RelativeTimeFormat>
  ): RelativeTimeFormat;
  getPluralRules(...args: ConstructorParameters<typeof Intl.PluralRules>): Intl$PluralRules;
  getListFormat(...args: ConstructorParameters<typeof ListFormat>): ListFormat;
  getDisplayNames(...args: ConstructorParameters<typeof DisplayNames>): DisplayNames;
}
interface Formatters_2 {
  getNumberFormat(...args: ConstructorParameters<typeof Intl.NumberFormat>): Intl$NumberFormat;
  getDateTimeFormat(
    ...args: ConstructorParameters<typeof Intl.DateTimeFormat>
  ): Intl$DateTimeFormat;
  getPluralRules(...args: ConstructorParameters<typeof Intl.PluralRules>): Intl$PluralRules;
}

type FormatXMLElementFn<T, R = string | Array<string | T>> = (
  parts: Array<string | T>,
) => R;
declare export function injectIntl<IntlPropName: string, P: WrappedComponentProps<IntlPropName>>(
  WrappedComponent: React$ComponentType<P>,
  options?: Opts<IntlPropName, false>,
): React$StatelessFunctionalComponent<WithIntlProps<P>> & {
  WrappedComponent: React$ComponentType<P>,
  ...
};
declare export function injectIntl<
  IntlPropName: string,
  P: WrappedComponentProps<IntlPropName>,
  T: React$ComponentType<P>,
>(
  WrappedComponent: React$ComponentType<P>,
  options?: Opts<IntlPropName, true>,
): React$AbstractComponent<
  {|
    ...WithIntlProps<P>,
    children?: React$Node,
    ref?: React$Ref<T>,
  |},
  mixed,
> & {
  WrappedComponent: React$ComponentType<P>,
  ...
};
export interface IntlCache {
  dateTime: {| [key: string]: Intl.DateTimeFormat |};
  number: {| [key: string]: Intl.NumberFormat |};
  message: {| [key: string]: IntlMessageFormat |};
  relativeTime: {| [key: string]: RelativeTimeFormat |};
  pluralRules: {| [key: string]: typeof Intl.PluralRules |};
  list: {| [key: string]: ListFormat |};
  displayNames: {| [key: string]: DisplayNames |};
}
export type IntlConfig = {
  locale: string;
  timeZone?: string;
  formats: CustomFormats;
  textComponent?: React$ElementType,
  messages: {| [key: string]: string |} | {| [key: string]: MessageFormatElement[] |};
  defaultLocale: string;
  defaultFormats: CustomFormats;
  wrapRichTextChunksInFragment?: boolean;
  onError(
    err: | MissingTranslationError
      | MessageFormatError
      | MissingDataError
      | InvalidConfigError
      | UnsupportedFormatterError
      | FormatError,
  ): void;
}
declare export var IntlContext: React$Context<IntlShape>;
export interface IntlFormatters<T = React$Node, R = T> {
  formatDate(
    value: Date | number | string, // Param of Intl.DateTimeFormat.prototype.format(), or `string`
    opts?: FormatDateOptions,
  ): string;
  formatTime(
    value: Date | number | string, // Param of Intl.DateTimeFormat.prototype.format(), or `string`
    opts?: FormatDateOptions,
  ): string;
  formatDateToParts(
    value: Date | number | string, // Param of Intl.DateTimeFormat.prototype.format(), or `string`
    opts?: FormatDateOptions,
  ): $Call<Intl$DateTimeFormat['formatToParts'], mixed[]>;
  formatTimeToParts(
    value: Date | number | string, // Param of Intl.DateTimeFormat.prototype.format(), or `string`
    opts?: FormatDateOptions,
  ): $Call<Intl$DateTimeFormat['formatToParts'], mixed[]>;
  formatRelativeTime(
    value: number, // First param of our RelativeTimeFormat.prototype.format()
    unit?: FormattableUnit, // Second param of our RelativeTimeFormat.prototype.format()
    opts?: FormatRelativeTimeOptions,
  ): string;
  formatNumber(
    value: number, // Param of Intl.NumberFormat.prototype.format()
    opts?: FormatNumberOptions,
  ): string;
  formatNumberToParts(
    value: number, // Param of Intl.NumberFormat.prototype.format()
    opts?: FormatNumberOptions,

    // Callers will get a Flow error until Flow adds a built-in
    // definition for Intl.NumberFormat.prototype.formatToParts():
    //   https://github.com/facebook/flow/issues/8859
  ): $Call<Intl$NumberFormat['formatToParts'], mixed[]>;
  formatPlural(
    value: number, // Param of Intl.PluralRules.prototype.select()
    opts?: FormatPluralOptions,
  ): $Call<<R>((...args: $FlowFixMe[]) => R) => R, typeof Intl.PluralRules['select']>;
  formatMessage(
    descriptor: MessageDescriptor,
    // The `+` was added to make the properties covariant rather
    // than invariant, something TypeScript can't do.
    values?: {| +[key: string]: PrimitiveType | FormatXMLElementFn<string, string> |},
  ): string;
  formatMessage(
    descriptor: MessageDescriptor,
    // The `+` was added to make the properties covariant rather
    // than invariant, something TypeScript can't do.
    values?: {| +[key: string]: PrimitiveType | React$Node | FormatXMLElementFn<T, R> |},
  ): React$Node;
  formatList(values: Array<string>, opts?: FormatListOptions): string;
  formatList(values: Array<string | React$Node>, opts?: FormatListOptions): React$Node;
  formatDisplayName(
    // First param of our DisplayNames.prototype.of()
    value: string | number | {| [key: string]: $FlowFixMe |},

    opts?: FormatDisplayNameOptions,
  ): string | void;
}
interface IntlListFormatOptions {
  /**
   * The locale matching algorithm to use.
   * Possible values are "lookup" and "best fit"; the default is "best fit".
   * For information about this option, see
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation.
   */
  localeMatcher?: 'best fit' | 'lookup';

  /**
   * The format of output message. Possible values are:
   * - "always" (default, e.g., 1 day ago),
   * - or "auto" (e.g., yesterday).
   * The "auto" value allows to not always have to
   * use numeric values in the output.
   */
  type?: 'conjunction' | 'disjunction' | 'unit';

  /**
   * The length of the internationalized message. Possible values are:
   * - "long" (default, e.g., in 1 month)
   * - "short" (e.g., in 1 mo.),
   * - or "narrow" (e.g., in 1 mo.).
   * The narrow style could be similar to the short style for some locales.
   */
  style?: 'long' | 'short' | 'narrow';
}
declare class IntlMessageFormat {
  constructor(
    message: string | MessageFormatElement[],
    locales?: string | string[],
    overrideFormats?: $Rest<Formats, { ... }>,
    opts?: Options,
  ): this;
  format: <T>(
    values?: {|
      [key: string]: | string
        | number
        | boolean
        | Date
        | T
        | FormatXMLElementFn<T, string | (string | T)[]>
        | null
        | void,
    |} | void,
  ) => string | T | (string | T)[];
  formatToParts: <T>(
    values?: {|
      [key: string]: | string
        | number
        | boolean
        | Date
        | T
        | FormatXMLElementFn<T, string | (string | T)[]>
        | null
        | void,
    |} | void,
  ) => MessageFormatPart<T>[];
  resolvedOptions: () => {
    locale: string,
    ...
  };
  getAst: () => MessageFormatElement[];
  defaultLocale: string;
  static __parse: typeof parse | void;
  static formats: {
    number: {
      currency: {
        style: string,
        ...
      },
      percent: {
        style: string,
        ...
      },
      ...
    },
    date: {
      short: {
        month: string,
        day: string,
        year: string,
        ...
      },
      medium: {
        month: string,
        day: string,
        year: string,
        ...
      },
      long: {
        month: string,
        day: string,
        year: string,
        ...
      },
      full: {
        weekday: string,
        month: string,
        day: string,
        year: string,
        ...
      },
      ...
    },
    time: {
      short: {
        hour: string,
        minute: string,
        ...
      },
      medium: {
        hour: string,
        minute: string,
        second: string,
        ...
      },
      long: {
        hour: string,
        minute: string,
        second: string,
        timeZoneName: string,
        ...
      },
      full: {
        hour: string,
        minute: string,
        second: string,
        timeZoneName: string,
        ...
      },
      ...
    },
    ...
  };
}
declare export class IntlProvider extends React$PureComponent<
  // Changed `mixins` to `extends` in TS to Flow translation
  {|
    ...OptionalIntlConfig,
    children?: React$Node,
  |},
  State,
> {
  static defaultProps: SubsetProperties<
    IntlConfig,
    {
      formats: mixed,
      timeZone?: mixed,
      onError: mixed,
      messages: mixed,
      textComponent?: mixed,
      defaultLocale: mixed,
      defaultFormats: mixed,
    }
  >;
  state: State;
  static getDerivedStateFromProps(
    props: OptionalIntlConfig,
    x: State,
  ): $Rest<State, { ... }> | null;
  render(): React$Node;
}
interface IntlRelativeTimeFormatOptions {
  /**
   * The locale matching algorithm to use.
   * Possible values are "lookup" and "best fit"; the default is "best fit".
   * For information about this option, see
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_negotiation.
   */
  localeMatcher?: 'best fit' | 'lookup';

  /**
   * The format of output message. Possible values are:
   * - "always" (default, e.g., 1 day ago),
   * - or "auto" (e.g., yesterday).
   * The "auto" value allows to not always have to
   * use numeric values in the output.
   */
  numeric?: 'always' | 'auto';

  /**
   * The length of the internationalized message. Possible values are:
   * - "long" (default, e.g., in 1 month)
   * - "short" (e.g., in 1 mo.),
   * - or "narrow" (e.g., in 1 mo.).
   * The narrow style could be similar to the short style for some locales.
   */
  style?: 'long' | 'short' | 'narrow';
}
export type IntlShape = {
  formatters: Formatters,
  ...
} & IntlConfig &
  IntlFormatters<>;
declare export class InvalidConfigError
  mixins ReactIntlError<typeof ReactIntlErrorCode.INVALID_CONFIG> {
  constructor(message: string, exception?: Error): this;
}
interface IParseOptions {
  filename?: string;
  startRule?: string;
  tracer?: $FlowFixMe;
  [key: string]: $FlowFixMe;
}
type LanguageTag = string;
type LDMLPluralRule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other';
declare class ListFormat {
  constructor(locales?: string | string[], options?: IntlListFormatOptions): this;
  format(elements: string[]): string;
  formatToParts(elements: string[]): Part_2[];
  resolvedOptions(): ResolvedIntlListFormatOptions;
  static supportedLocalesOf(
    locales: string | string[],
    options?: SubsetProperties<IntlListFormatOptions, {| localeMatcher?: mixed |}>,
  ): string[];
  static __addLocaleData(...data: ListPatternLocaleData[]): void;
  static localeData: {| [key: string]: ListPatternFieldsData |};
  static polyfilled: boolean;
}
interface ListPattern {
  start: string;
  middle: string;
  end: string;
  pair: string;
}
interface ListPatternData {
  long: ListPattern;
  short?: ListPattern;
  narrow?: ListPattern;
}
interface ListPatternFieldsData {
  conjunction?: ListPatternData;
  disjunction?: ListPatternData;
  unit?: ListPatternData;
}
type ListPatternLocaleData = LocaleData<ListPatternFieldsData>;
type LiteralElement = BaseElement<typeof TYPE.literal>;
interface LiteralPart {
  type: 'literal';
  value: string;
}
interface LiteralPart_2 {
  type: typeof PART_TYPE.literal;
  value: string;
}
type Locale = string;
interface LocaleData<T> {
  data: {| [key: Locale]: T |};
  availableLocales: string[];
}
type LocaleFieldsData = $ObjMapi<
  {| [k: RelativeTimeField]: $FlowFixMe |},
  <f>(f) => FieldData, > & {
  nu?: Array<string | null>,
  ...
};
interface Location_2 {
  start: LocationDetails;
  end: LocationDetails;
}
interface LocationDetails {
  offset: number;
  line: number;
  column: number;
}
// Changed from interface to type in TS to Flow translation
export type MessageDescriptor = {|
  id?: string | number,
  description?: string | {| [key: string]: $FlowFixMe |},
  defaultMessage?: string,
|};
type MessageFormatElement =
  | LiteralElement
  | ArgumentElement
  | NumberElement
  | DateElement
  | TimeElement
  | SelectElement
  | PluralElement
  | TagElement
  | PoundElement;
declare export class MessageFormatError
  mixins ReactIntlError<typeof ReactIntlErrorCode.FORMAT_ERROR> {
  +descriptor?: MessageDescriptor;
  constructor(
    message: string,
    locale: string,
    descriptor?: MessageDescriptor,
    exception?: Error,
  ): this;
}
type MessageFormatPart<T> = LiteralPart_2 | ObjectPart<T>;
declare export class MissingDataError
  mixins ReactIntlError<typeof ReactIntlErrorCode.MISSING_DATA> {
  constructor(message: string, exception?: Error): this;
}
declare export class MissingTranslationError
  mixins ReactIntlError<typeof ReactIntlErrorCode.MISSING_TRANSLATION> {
  +descriptor?: MessageDescriptor;
  constructor(descriptor: MessageDescriptor, locale: string): this;
}
type NumberElement = SimpleFormatElement<typeof TYPE._number, NumberSkeleton>;
interface NumberFormatDigitOptions {
  minimumIntegerDigits?: number;
  minimumSignificantDigits?: number;
  maximumSignificantDigits?: number;
  minimumFractionDigits?: number;
  maximumFractionDigits?: number;
}
type NumberFormatNotation = 'standard' | 'scientific' | 'engineering' | 'compact';
type NumberFormatOptions = Intl$NumberFormatOptions &
  NumberFormatDigitOptions & {
    localeMatcher?: NumberFormatOptionsLocaleMatcher,
    style?: NumberFormatOptionsStyle,
    compactDisplay?: NumberFormatOptionsCompactDisplay,
    currencyDisplay?: NumberFormatOptionsCurrencyDisplay,
    currencySign?: NumberFormatOptionsCurrencySign,
    notation?: NumberFormatOptionsNotation,
    signDisplay?: NumberFormatOptionsSignDisplay,
    unit?: string,
    unitDisplay?: NumberFormatOptionsUnitDisplay,
    numberingSystem?: string,
    ...
  };
type NumberFormatOptionsCompactDisplay = 'short' | 'long';
type NumberFormatOptionsCurrencyDisplay = 'symbol' | 'code' | 'name' | 'narrowSymbol';
type NumberFormatOptionsCurrencySign = 'standard' | 'accounting';
type NumberFormatOptionsLocaleMatcher = 'lookup' | 'best fit';
type NumberFormatOptionsNotation = NumberFormatNotation;
type NumberFormatOptionsSignDisplay = 'auto' | 'always' | 'never' | 'exceptZero';
type NumberFormatOptionsStyle = 'decimal' | 'percent' | 'currency' | 'unit';
type NumberFormatOptionsUnitDisplay = 'long' | 'short' | 'narrow';
interface NumberSkeleton {
  type: typeof SKELETON_TYPE._number;
  tokens: NumberSkeletonToken[];
  location?: Location_2;
}
interface NumberSkeletonToken {
  stem: string;
  options: string[];
}
interface ObjectPart<T = $FlowFixMe> {
  type: typeof PART_TYPE.object;
  value: T;
}
type OptionalIntlConfig = { ...IntlConfig, ...$Rest<typeof DEFAULT_INTL_CONFIG, { ... }> };
interface Options {
  formatters?: Formatters_2;

  /**
   * Whether to treat HTML/XML tags as string literal
   * instead of parsing them as tag token.
   * When this is false we only allow simple tags without
   * any attributes
   */
  ignoreTag?: boolean;
}
interface Options_2 {
  /**
   * Whether to convert `#` in plural rule options
   * to `{var, number}`
   * Default is true
   */
  normalizeHashtagInPlural?: boolean;

  /**
   * Capture location info in AST
   * Default is false
   */
  captureLocation?: boolean;

  /**
   * Whether to treat HTML/XML tags as string literal
   * instead of parsing them as tag token.
   * When this is false we only allow simple tags without
   * any attributes
   */
  ignoreTag?: boolean;
}
interface Opts<IntlPropName: string = 'intl', ForwardRef: boolean = false> {
  intlPropName?: IntlPropName;
  forwardRef?: ForwardRef;
  enforceContext?: boolean;
}
declare function parse(input: string, opts?: ParseOptions): MessageFormatElement[];
type ParseOptions = Options_2 & IParseOptions;
type Part = LiteralPart | RelativeTimeFormatNumberPart;
type Part_2 = LiteralPart | ElementPart;
declare var PART_TYPE: {|
  +literal: 0, // 0
  +object: 1, // 1
|};
type PluralElement = {
  options: {| [key: ValidPluralRule]: PluralOrSelectOption |},
  offset: number,
  pluralType: Intl$PluralRulesOptions['type'],
  ...
} & BaseElement<typeof TYPE.plural>;
interface PluralOrSelectOption {
  value: MessageFormatElement[];
  location?: Location_2;
}
interface PoundElement {
  type: typeof TYPE.pound;
  location?: Location_2;
}
type PrimitiveType = string | number | boolean | null | void | Date;
type Props = {
  value?: number,
  unit?: Unit,
  updateIntervalInSeconds?: number,
  children?: (value: string) => React$Element<React$ElementType> | string | number,
  ...
} & FormatRelativeTimeOptions;
type Props_2 = {
  value: number,
  intl: IntlShape,
  other: React$Node,
  zero?: React$Node,
  one?: React$Node,
  two?: React$Node,
  few?: React$Node,
  many?: React$Node,
  children?: (value: React$Node) => React$Element<React$ElementType> | null,
  ...
} & FormatPluralOptions;
type Props_3<V: {| +[key: string]: $FlowFixMe |} = {| +[key: string]: React$Node |}> = {
  ...MessageDescriptor,
  values?: V,
  tagName?: React$ElementType,
  children?: (...nodes: React$Node[]) => React$Node,
  ...
};
declare export var RawIntlProvider: React$ComponentType<{
  value: IntlShape,
  children?: React$Node,
  ...
}>;
declare export class ReactIntlError<
  T: $Values<typeof ReactIntlErrorCode> = typeof ReactIntlErrorCode.FORMAT_ERROR,
> mixins Error {
  +code: T;
  constructor(code: T, message: string, exception?: Error): this;
}
declare export var ReactIntlErrorCode: {|
  +FORMAT_ERROR: 'FORMAT_ERROR', // "FORMAT_ERROR"
  +UNSUPPORTED_FORMATTER: 'UNSUPPORTED_FORMATTER', // "UNSUPPORTED_FORMATTER"
  +INVALID_CONFIG: 'INVALID_CONFIG', // "INVALID_CONFIG"
  +MISSING_DATA: 'MISSING_DATA', // "MISSING_DATA"
  +MISSING_TRANSLATION: 'MISSING_TRANSLATION', // "MISSING_TRANSLATION"
|};
type RegionCode = string;
type RelativeTimeData = $ObjMapi<{| [k: LDMLPluralRule]: $FlowFixMe |}, <u>(u) => string>;
type RelativeTimeField =
  | 'second'
  | 'second-short'
  | 'second-narrow'
  | 'minute'
  | 'minute-short'
  | 'minute-narrow'
  | 'hour'
  | 'hour-short'
  | 'hour-narrow'
  | 'day'
  | 'day-short'
  | 'day-narrow'
  | 'week'
  | 'week-short'
  | 'week-narrow'
  | 'month'
  | 'month-short'
  | 'month-narrow'
  | 'quarter'
  | 'quarter-short'
  | 'quarter-narrow'
  | 'year'
  | 'year-short'
  | 'year-narrow';
declare class RelativeTimeFormat {
  constructor(locales?: string | string[], options?: IntlRelativeTimeFormatOptions): this;
  format(value: number, unit: FormattableUnit): string;
  formatToParts(value: number, unit: FormattableUnit): Part[];
  resolvedOptions(): ResolvedIntlRelativeTimeFormatOptions;
  static supportedLocalesOf(
    locales: string | string[],
    options?: SubsetProperties<IntlRelativeTimeFormatOptions, {| localeMatcher?: mixed |}>,
  ): string[];
  static __addLocaleData(...data: RelativeTimeLocaleData[]): void;
  static localeData: {| [key: string]: LocaleFieldsData |};
  static polyfilled: boolean;
}
type RelativeTimeFormatNumberPart = {
  unit: Unit,
  ...

  // Callers will get a Flow error until Flow adds a built-in
  // definition for Intl.NumberFormat.prototype.formatToParts():
  //   https://github.com/facebook/flow/issues/8859
} & $Call<Intl$NumberFormat['formatToParts'], mixed[]>[number];
type RelativeTimeLocaleData = LocaleData<LocaleFieldsData>;
interface ResolvedIntlListFormatOptions {
  /**
   * The BCP 47 language tag for the locale actually used.
   * If any Unicode extension values were requested in the
   * input BCP 47 language tag that led to this locale,
   * the key-value pairs that were requested and are
   * supported for this locale are included in locale.
   */
  locale: string;

  /**
   * The format of output message. Possible values are:
   * - "always" (default, e.g., 1 day ago),
   * - or "auto" (e.g., yesterday).
   * The "auto" value allows to not always have to
   * use numeric values in the output.
   */
  type: 'conjunction' | 'disjunction' | 'unit';

  /**
   * The length of the internationalized message. Possible values are:
   * - "long" (default, e.g., in 1 month)
   * - "short" (e.g., in 1 mo.),
   * - or "narrow" (e.g., in 1 mo.).
   * The narrow style could be similar to the short style for some locales.
   */
  style: 'long' | 'short' | 'narrow';
}
type ResolvedIntlRelativeTimeFormatOptions = {
  /**
   * The BCP 47 language tag for the locale actually used.
   * If any Unicode extension values were requested in the
   * input BCP 47 language tag that led to this locale,
   * the key-value pairs that were requested and are
   * supported for this locale are included in locale.
   */
  locale: string,

  /**
   * The value requested using the Unicode
   * extension key "nu" or filled in as a default.
   */
  numberingSystem: string,
  ...
};
type ScriptCode = string;
type SelectElement = {
  options: {| [key: string]: PluralOrSelectOption |},
  ...
} & BaseElement<typeof TYPE.select>;
type SimpleFormatElement<T: $Values<typeof TYPE>, S: Skeleton> = {
  style?: string | S | null,
  ...
} & BaseElement<T>;
type Skeleton = NumberSkeleton | DateTimeSkeleton;
declare var SKELETON_TYPE: {|
  // Underscore added in TS to Flow translation ("Unexpected reserved type")
  +_number: 0, // 0
  +dateTime: 1, // 1
|};
interface State {
  /**
   * Explicit intl cache to prevent memory leaks
   */
  cache: IntlCache;

  /**
   * Intl object we created
   */
  intl?: IntlShape;

  /**
   * list of memoized config we care about.
   * This is important since creating intl is
   * very expensive
   */
  prevConfig: OptionalIntlConfig;
}
interface State_2 {
  prevUnit?: Unit;
  prevValue?: number;
  currentValueInSeconds: number;
}
interface TagElement {
  type: typeof TYPE.tag;
  value: string;
  children: MessageFormatElement[];
  location?: Location_2;
}
type TimeElement = SimpleFormatElement<typeof TYPE.time, DateTimeSkeleton>;
declare var TYPE: {|
  +literal: 0, // 0
  +argument: 1, // 1
  // Underscore added in TS to Flow translation ("Unexpected reserved type")
  +_number: 2, // 2
  +date: 3, // 3
  +time: 4, // 4
  +select: 5, // 5
  +plural: 6, // 6
  +pound: 7, // 7
  +tag: 8, // 8
|};
type Unit = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';
type Units =
  | 'seconds'
  | 'minutes'
  | 'hours'
  | 'days'
  | 'weeks'
  | 'months'
  | 'quarters'
  | 'years';
declare export class UnsupportedFormatterError
  mixins ReactIntlError<typeof ReactIntlErrorCode.UNSUPPORTED_FORMATTER> {
  constructor(message: string, exception?: Error): this;
}
declare export function useIntl(): IntlShape;
type ValidPluralRule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' | string;
export type WithIntlProps<P> = $Rest<P, WrappedComponentProps<>> & {
  forwardedRef?: React$Ref<$FlowFixMe>,
  ...
};
export type WrappedComponentProps<IntlPropName: string = 'intl'> = $ObjMapi<
  {| [k: IntlPropName]: $FlowFixMe |},
  <k>(k) => IntlShape, >;
declare export {};
