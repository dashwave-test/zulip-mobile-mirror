/* @flow
 * @generated by TsFlower
 */
import type { Extract, Readonly, Partial } from 'tsflower/subst/lib';
import * as CommonActions from './CommonActions';
export type CommonNavigationAction = CommonActions.Action;
type NavigationRoute<+ParamList: ParamListBase, +RouteName: $Keys<ParamList>> = Route<
  Extract<RouteName, string>,
  $ElementType<ParamList, RouteName>,
> & { +state?: NavigationState<ParamList> | PartialState<NavigationState<ParamList>>, ... };

export type NavigationState<+ParamList: ParamListBase = ParamListBase> = $ReadOnly<{
  key: string,
  index: number,
  routeNames: $ReadOnlyArray<Extract<$Keys<ParamList>, string>>,
  history?: $ReadOnlyArray<mixed>,
  routes: $ReadOnlyArray<NavigationRoute<ParamList, $Keys<ParamList>>>,
  type: string,
  stale: false,
  ...
}>;

export type InitialState = Readonly<
  Partial<
    $Diff<
      NavigationState<>,
      {|
        stale: mixed,
        routes: mixed,
      |},
    >,
  > & { routes: $Diff<Route<string>, {| key: mixed |}> & { state?: InitialState, ... }[], ... },
>;

export type PartialRoute<R: Route<string>> = $Diff<R, {| key: mixed |}> & {
  key?: string,
  state?: PartialState<NavigationState<>>,
  ...
};

export type PartialState<+State: NavigationState<>> = Partial<
  $Diff<
    State,
    {|
      stale: mixed,
      routes: mixed,
    |},
  >,
> &
  Readonly<{
    stale?: true,
    routes: PartialRoute<Route<$ElementType<$ElementType<State, 'routeNames'>, number>>>[],
    ...
  }>;

export type Route<+RouteName: string, +Params: { ... } | void = { ... } | void> = $ReadOnly<{
  key: string,
  name: RouteName,
  params?: Params, // for conditional below
  ...
}> /* undefined extends Params ? Readonly<{
    /**
     * Params for this route
     * /
    params?: Readonly<Params>;
}> : Readonly<{
    /**
     * Params for this route
     * /
    params: Readonly<Params>;
}> */ /* tsflower-unimplemented: ConditionalType */; // manually added above

export type ParamListBase = { +[key: string]: { ... } | void };

export type NavigationAction = Readonly<{
  type: string,
  payload?: { ... },
  source?: string,
  target?: string,
  ...
}>;

export type ActionCreators<Action: NavigationAction> = {
  [key: string]: (...args: any) => Action,
  ...
};
export type DefaultRouterOptions<RouteName: string = string> = {
  initialRouteName?: RouteName,
  ...
};
export type RouterFactory<
  State: NavigationState<>,
  Action: NavigationAction,
  RouterOptions: DefaultRouterOptions<>,
> = (options: RouterOptions) => Router<State, Action>;

export type RouterConfigOptions = {
  routeNames: string[],
  routeParamList: ParamListBase,
  routeGetIdList: {
    [key: string]: (options: { params?: { [key: string]: any }, ... }) => string | void | void,
  },
  ...
};

export type Router<State: NavigationState<>, Action: NavigationAction> = {
  type: $ElementType<State, 'type'>,
  getInitialState(options: RouterConfigOptions): State,
  getRehydratedState(
    partialState: PartialState<State> | State,
    options: RouterConfigOptions,
  ): State,
  getStateForRouteNamesChange(state: State, options: RouterConfigOptions): State,
  getStateForRouteFocus(state: State, key: string): State,
  getStateForAction(
    state: State,
    action: Action,
    options: RouterConfigOptions,
  ): State | PartialState<State> | null,
  shouldActionChangeFocus(action: NavigationAction): boolean,
  actionCreators?: ActionCreators<Action>,
  ...
};

export {};
